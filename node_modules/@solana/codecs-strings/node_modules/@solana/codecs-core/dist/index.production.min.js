this.globalThis = this.globalThis || {};
this.globalThis.solanaWeb3 = (function (exports) {
	'use strict';

	function E(e,r,o=0){if(r.length-o<=0)throw new Error(`Codec [${e}] cannot decode empty byte arrays.`)}function s(e,r,o,n=0){let t=o.length-n;if(t<r)throw new Error(`Codec [${e}] expected ${r} bytes, got ${t}.`)}function a(e,r){if(e.fixedSize===null)throw new Error(r??"Expected a fixed-size codec, got a variable-size one.")}var u=e=>{let r=e.filter(i=>i.length);if(r.length===0)return e.length?e[0]:new Uint8Array;if(r.length===1)return r[0];let o=r.reduce((i,p)=>i+p.length,0),n=new Uint8Array(o),t=0;return r.forEach(i=>{n.set(i,t),t+=i.length;}),n},f=(e,r)=>{if(e.length>=r)return e;let o=new Uint8Array(r).fill(0);return o.set(e),o},m=(e,r)=>f(e.length<=r?e:e.slice(0,r),r);function c(e,r,o){if(e.fixedSize!==r.fixedSize)throw new Error(`Encoder and decoder must have the same fixed size, got [${e.fixedSize}] and [${r.fixedSize}].`);if(e.maxSize!==r.maxSize)throw new Error(`Encoder and decoder must have the same max size, got [${e.maxSize}] and [${r.maxSize}].`);if(o===void 0&&e.description!==r.description)throw new Error(`Encoder and decoder must have the same description, got [${e.description}] and [${r.description}]. Pass a custom description as a third argument if you want to override the description and bypass this error.`);return {decode:r.decode,description:o??e.description,encode:e.encode,fixedSize:e.fixedSize,maxSize:e.maxSize}}function x(e,r,o){return {description:o??`fixed(${r}, ${e.description})`,fixedSize:r,maxSize:r}}function l(e,r,o){return {...x(e,r,o),encode:n=>m(e.encode(n),r)}}function T(e,r,o){return {...x(e,r,o),decode:(n,t=0)=>{s("fixCodec",r,n,t),(t>0||n.length>r)&&(n=n.slice(t,t+r)),e.fixedSize!==null&&(n=m(n,e.fixedSize));let[i]=e.decode(n,0);return [i,t+r]}}}function $(e,r,o){return c(l(e,r,o),T(e,r,o))}function z(e,r){return {description:e.description,encode:o=>e.encode(r(o)),fixedSize:e.fixedSize,maxSize:e.maxSize}}function w(e,r){return {decode:(o,n=0)=>{let[t,i]=e.decode(o,n);return [r(t,o,n),i]},description:e.description,fixedSize:e.fixedSize,maxSize:e.maxSize}}function _(e,r,o){return {decode:o?w(e,o).decode:e.decode,description:e.description,encode:z(e,r).encode,fixedSize:e.fixedSize,maxSize:e.maxSize}}function C(e){return a(e,"Cannot reverse a codec of variable size."),{...e,encode:r=>e.encode(r).reverse()}}function F(e){return a(e,"Cannot reverse a codec of variable size."),{...e,decode:(r,o=0)=>{let n=o+e.fixedSize;if(o===0&&r.length===n)return e.decode(r.reverse(),o);let t=u([...o===0?[]:[r.slice(0,o)],r.slice(o,n).reverse(),...r.length===n?[]:[r.slice(n)]]);return e.decode(t,o)}}}function I(e){return c(C(e),F(e))}

	exports.assertByteArrayHasEnoughBytesForCodec = s;
	exports.assertByteArrayIsNotEmptyForCodec = E;
	exports.assertFixedSizeCodec = a;
	exports.combineCodec = c;
	exports.fixBytes = m;
	exports.fixCodec = $;
	exports.fixDecoder = T;
	exports.fixEncoder = l;
	exports.mapCodec = _;
	exports.mapDecoder = w;
	exports.mapEncoder = z;
	exports.mergeBytes = u;
	exports.padBytes = f;
	exports.reverseCodec = I;
	exports.reverseDecoder = F;
	exports.reverseEncoder = C;

	return exports;

})({});
