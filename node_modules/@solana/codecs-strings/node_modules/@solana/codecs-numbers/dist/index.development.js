this.globalThis = this.globalThis || {};
this.globalThis.solanaWeb3 = (function (exports) {
  'use strict';

  // src/assertions.ts
  function assertNumberIsBetweenForCodec(codecDescription, min, max, value) {
    if (value < min || value > max) {
      throw new Error(
        `Codec [${codecDescription}] expected number to be in the range [${min}, ${max}], got ${value}.`
      );
    }
  }

  // src/common.ts
  var Endian = /* @__PURE__ */ ((Endian2) => {
    Endian2[Endian2["LITTLE"] = 0] = "LITTLE";
    Endian2[Endian2["BIG"] = 1] = "BIG";
    return Endian2;
  })(Endian || {});

  // ../codecs-core/dist/index.browser.js
  function assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {
    if (bytes.length - offset <= 0) {
      throw new Error(`Codec [${codecDescription}] cannot decode empty byte arrays.`);
    }
  }
  function assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {
    const bytesLength = bytes.length - offset;
    if (bytesLength < expected) {
      throw new Error(`Codec [${codecDescription}] expected ${expected} bytes, got ${bytesLength}.`);
    }
  }
  function combineCodec(encoder, decoder, description) {
    if (encoder.fixedSize !== decoder.fixedSize) {
      throw new Error(
        `Encoder and decoder must have the same fixed size, got [${encoder.fixedSize}] and [${decoder.fixedSize}].`
      );
    }
    if (encoder.maxSize !== decoder.maxSize) {
      throw new Error(
        `Encoder and decoder must have the same max size, got [${encoder.maxSize}] and [${decoder.maxSize}].`
      );
    }
    if (description === void 0 && encoder.description !== decoder.description) {
      throw new Error(
        `Encoder and decoder must have the same description, got [${encoder.description}] and [${decoder.description}]. Pass a custom description as a third argument if you want to override the description and bypass this error.`
      );
    }
    return {
      decode: decoder.decode,
      description: description ?? encoder.description,
      encode: encoder.encode,
      fixedSize: encoder.fixedSize,
      maxSize: encoder.maxSize
    };
  }

  // src/utils.ts
  function sharedNumberFactory(input) {
    let littleEndian;
    let defaultDescription = input.name;
    if (input.size > 1) {
      littleEndian = !("endian" in input.options) || input.options.endian === 0 /* LITTLE */;
      defaultDescription += littleEndian ? "(le)" : "(be)";
    }
    return {
      description: input.options.description ?? defaultDescription,
      fixedSize: input.size,
      littleEndian,
      maxSize: input.size
    };
  }
  function numberEncoderFactory(input) {
    const codecData = sharedNumberFactory(input);
    return {
      description: codecData.description,
      encode(value) {
        if (input.range) {
          assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);
        }
        const arrayBuffer = new ArrayBuffer(input.size);
        input.set(new DataView(arrayBuffer), value, codecData.littleEndian);
        return new Uint8Array(arrayBuffer);
      },
      fixedSize: codecData.fixedSize,
      maxSize: codecData.maxSize
    };
  }
  function numberDecoderFactory(input) {
    const codecData = sharedNumberFactory(input);
    return {
      decode(bytes, offset = 0) {
        assertByteArrayIsNotEmptyForCodec(codecData.description, bytes, offset);
        assertByteArrayHasEnoughBytesForCodec(codecData.description, input.size, bytes, offset);
        const view = new DataView(toArrayBuffer(bytes, offset, input.size));
        return [input.get(view, codecData.littleEndian), offset + input.size];
      },
      description: codecData.description,
      fixedSize: codecData.fixedSize,
      maxSize: codecData.maxSize
    };
  }
  function toArrayBuffer(bytes, offset, length) {
    const bytesOffset = bytes.byteOffset + (offset ?? 0);
    const bytesLength = length ?? bytes.byteLength;
    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);
  }

  // src/f32.ts
  var getF32Encoder = (options = {}) => numberEncoderFactory({
    name: "f32",
    options,
    set: (view, value, le) => view.setFloat32(0, value, le),
    size: 4
  });
  var getF32Decoder = (options = {}) => numberDecoderFactory({
    get: (view, le) => view.getFloat32(0, le),
    name: "f32",
    options,
    size: 4
  });
  var getF32Codec = (options = {}) => combineCodec(getF32Encoder(options), getF32Decoder(options));

  // src/f64.ts
  var getF64Encoder = (options = {}) => numberEncoderFactory({
    name: "f64",
    options,
    set: (view, value, le) => view.setFloat64(0, value, le),
    size: 8
  });
  var getF64Decoder = (options = {}) => numberDecoderFactory({
    get: (view, le) => view.getFloat64(0, le),
    name: "f64",
    options,
    size: 8
  });
  var getF64Codec = (options = {}) => combineCodec(getF64Encoder(options), getF64Decoder(options));

  // src/i128.ts
  var getI128Encoder = (options = {}) => numberEncoderFactory({
    name: "i128",
    options,
    range: [-BigInt("0x7fffffffffffffffffffffffffffffff") - 1n, BigInt("0x7fffffffffffffffffffffffffffffff")],
    set: (view, value, le) => {
      const leftOffset = le ? 8 : 0;
      const rightOffset = le ? 0 : 8;
      const rightMask = 0xffffffffffffffffn;
      view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);
      view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);
    },
    size: 16
  });
  var getI128Decoder = (options = {}) => numberDecoderFactory({
    get: (view, le) => {
      const leftOffset = le ? 8 : 0;
      const rightOffset = le ? 0 : 8;
      const left = view.getBigInt64(leftOffset, le);
      const right = view.getBigUint64(rightOffset, le);
      return (left << 64n) + right;
    },
    name: "i128",
    options,
    size: 16
  });
  var getI128Codec = (options = {}) => combineCodec(getI128Encoder(options), getI128Decoder(options));

  // src/i16.ts
  var getI16Encoder = (options = {}) => numberEncoderFactory({
    name: "i16",
    options,
    range: [-Number("0x7fff") - 1, Number("0x7fff")],
    set: (view, value, le) => view.setInt16(0, value, le),
    size: 2
  });
  var getI16Decoder = (options = {}) => numberDecoderFactory({
    get: (view, le) => view.getInt16(0, le),
    name: "i16",
    options,
    size: 2
  });
  var getI16Codec = (options = {}) => combineCodec(getI16Encoder(options), getI16Decoder(options));

  // src/i32.ts
  var getI32Encoder = (options = {}) => numberEncoderFactory({
    name: "i32",
    options,
    range: [-Number("0x7fffffff") - 1, Number("0x7fffffff")],
    set: (view, value, le) => view.setInt32(0, value, le),
    size: 4
  });
  var getI32Decoder = (options = {}) => numberDecoderFactory({
    get: (view, le) => view.getInt32(0, le),
    name: "i32",
    options,
    size: 4
  });
  var getI32Codec = (options = {}) => combineCodec(getI32Encoder(options), getI32Decoder(options));

  // src/i64.ts
  var getI64Encoder = (options = {}) => numberEncoderFactory({
    name: "i64",
    options,
    range: [-BigInt("0x7fffffffffffffff") - 1n, BigInt("0x7fffffffffffffff")],
    set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),
    size: 8
  });
  var getI64Decoder = (options = {}) => numberDecoderFactory({
    get: (view, le) => view.getBigInt64(0, le),
    name: "i64",
    options,
    size: 8
  });
  var getI64Codec = (options = {}) => combineCodec(getI64Encoder(options), getI64Decoder(options));

  // src/i8.ts
  var getI8Encoder = (options = {}) => numberEncoderFactory({
    name: "i8",
    options,
    range: [-Number("0x7f") - 1, Number("0x7f")],
    set: (view, value) => view.setInt8(0, value),
    size: 1
  });
  var getI8Decoder = (options = {}) => numberDecoderFactory({
    get: (view) => view.getInt8(0),
    name: "i8",
    options,
    size: 1
  });
  var getI8Codec = (options = {}) => combineCodec(getI8Encoder(options), getI8Decoder(options));

  // src/short-u16.ts
  var getShortU16Encoder = (options = {}) => ({
    description: options.description ?? "shortU16",
    encode: (value) => {
      assertNumberIsBetweenForCodec("shortU16", 0, 65535, value);
      const bytes = [0];
      for (let ii = 0; ; ii += 1) {
        const alignedValue = value >> ii * 7;
        if (alignedValue === 0) {
          break;
        }
        const nextSevenBits = 127 & alignedValue;
        bytes[ii] = nextSevenBits;
        if (ii > 0) {
          bytes[ii - 1] |= 128;
        }
      }
      return new Uint8Array(bytes);
    },
    fixedSize: null,
    maxSize: 3
  });
  var getShortU16Decoder = (options = {}) => ({
    decode: (bytes, offset = 0) => {
      let value = 0;
      let byteCount = 0;
      while (++byteCount) {
        const byteIndex = byteCount - 1;
        const currentByte = bytes[offset + byteIndex];
        const nextSevenBits = 127 & currentByte;
        value |= nextSevenBits << byteIndex * 7;
        if ((currentByte & 128) === 0) {
          break;
        }
      }
      return [value, offset + byteCount];
    },
    description: options.description ?? "shortU16",
    fixedSize: null,
    maxSize: 3
  });
  var getShortU16Codec = (options = {}) => combineCodec(getShortU16Encoder(options), getShortU16Decoder(options));

  // src/u128.ts
  var getU128Encoder = (options = {}) => numberEncoderFactory({
    name: "u128",
    options,
    range: [0, BigInt("0xffffffffffffffffffffffffffffffff")],
    set: (view, value, le) => {
      const leftOffset = le ? 8 : 0;
      const rightOffset = le ? 0 : 8;
      const rightMask = 0xffffffffffffffffn;
      view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);
      view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);
    },
    size: 16
  });
  var getU128Decoder = (options = {}) => numberDecoderFactory({
    get: (view, le) => {
      const leftOffset = le ? 8 : 0;
      const rightOffset = le ? 0 : 8;
      const left = view.getBigUint64(leftOffset, le);
      const right = view.getBigUint64(rightOffset, le);
      return (left << 64n) + right;
    },
    name: "u128",
    options,
    size: 16
  });
  var getU128Codec = (options = {}) => combineCodec(getU128Encoder(options), getU128Decoder(options));

  // src/u16.ts
  var getU16Encoder = (options = {}) => numberEncoderFactory({
    name: "u16",
    options,
    range: [0, Number("0xffff")],
    set: (view, value, le) => view.setUint16(0, value, le),
    size: 2
  });
  var getU16Decoder = (options = {}) => numberDecoderFactory({
    get: (view, le) => view.getUint16(0, le),
    name: "u16",
    options,
    size: 2
  });
  var getU16Codec = (options = {}) => combineCodec(getU16Encoder(options), getU16Decoder(options));

  // src/u32.ts
  var getU32Encoder = (options = {}) => numberEncoderFactory({
    name: "u32",
    options,
    range: [0, Number("0xffffffff")],
    set: (view, value, le) => view.setUint32(0, value, le),
    size: 4
  });
  var getU32Decoder = (options = {}) => numberDecoderFactory({
    get: (view, le) => view.getUint32(0, le),
    name: "u32",
    options,
    size: 4
  });
  var getU32Codec = (options = {}) => combineCodec(getU32Encoder(options), getU32Decoder(options));

  // src/u64.ts
  var getU64Encoder = (options = {}) => numberEncoderFactory({
    name: "u64",
    options,
    range: [0, BigInt("0xffffffffffffffff")],
    set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),
    size: 8
  });
  var getU64Decoder = (options = {}) => numberDecoderFactory({
    get: (view, le) => view.getBigUint64(0, le),
    name: "u64",
    options,
    size: 8
  });
  var getU64Codec = (options = {}) => combineCodec(getU64Encoder(options), getU64Decoder(options));

  // src/u8.ts
  var getU8Encoder = (options = {}) => numberEncoderFactory({
    name: "u8",
    options,
    range: [0, Number("0xff")],
    set: (view, value) => view.setUint8(0, value),
    size: 1
  });
  var getU8Decoder = (options = {}) => numberDecoderFactory({
    get: (view) => view.getUint8(0),
    name: "u8",
    options,
    size: 1
  });
  var getU8Codec = (options = {}) => combineCodec(getU8Encoder(options), getU8Decoder(options));

  exports.Endian = Endian;
  exports.assertNumberIsBetweenForCodec = assertNumberIsBetweenForCodec;
  exports.getF32Codec = getF32Codec;
  exports.getF32Decoder = getF32Decoder;
  exports.getF32Encoder = getF32Encoder;
  exports.getF64Codec = getF64Codec;
  exports.getF64Decoder = getF64Decoder;
  exports.getF64Encoder = getF64Encoder;
  exports.getI128Codec = getI128Codec;
  exports.getI128Decoder = getI128Decoder;
  exports.getI128Encoder = getI128Encoder;
  exports.getI16Codec = getI16Codec;
  exports.getI16Decoder = getI16Decoder;
  exports.getI16Encoder = getI16Encoder;
  exports.getI32Codec = getI32Codec;
  exports.getI32Decoder = getI32Decoder;
  exports.getI32Encoder = getI32Encoder;
  exports.getI64Codec = getI64Codec;
  exports.getI64Decoder = getI64Decoder;
  exports.getI64Encoder = getI64Encoder;
  exports.getI8Codec = getI8Codec;
  exports.getI8Decoder = getI8Decoder;
  exports.getI8Encoder = getI8Encoder;
  exports.getShortU16Codec = getShortU16Codec;
  exports.getShortU16Decoder = getShortU16Decoder;
  exports.getShortU16Encoder = getShortU16Encoder;
  exports.getU128Codec = getU128Codec;
  exports.getU128Decoder = getU128Decoder;
  exports.getU128Encoder = getU128Encoder;
  exports.getU16Codec = getU16Codec;
  exports.getU16Decoder = getU16Decoder;
  exports.getU16Encoder = getU16Encoder;
  exports.getU32Codec = getU32Codec;
  exports.getU32Decoder = getU32Decoder;
  exports.getU32Encoder = getU32Encoder;
  exports.getU64Codec = getU64Codec;
  exports.getU64Decoder = getU64Decoder;
  exports.getU64Encoder = getU64Encoder;
  exports.getU8Codec = getU8Codec;
  exports.getU8Decoder = getU8Decoder;
  exports.getU8Encoder = getU8Encoder;

  return exports;

})({});
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.development.js.map