{"version":3,"sources":["../src/assertions.ts","../src/common.ts","../src/f32.ts","../src/utils.ts","../src/f64.ts","../src/i128.ts","../src/i16.ts","../src/i32.ts","../src/i64.ts","../src/i8.ts","../src/short-u16.ts","../src/u128.ts","../src/u16.ts","../src/u32.ts","../src/u64.ts","../src/u8.ts"],"names":["Endian","combineCodec"],"mappings":"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","sourcesContent":["/**\n * Asserts that a given number is between a given range.\n */\nexport function assertNumberIsBetweenForCodec(\n    codecDescription: string,\n    min: number | bigint,\n    max: number | bigint,\n    value: number | bigint\n) {\n    if (value < min || value > max) {\n        // TODO: Coded error.\n        throw new Error(\n            `Codec [${codecDescription}] expected number to be in the range [${min}, ${max}], got ${value}.`\n        );\n    }\n}\n","import { BaseCodecOptions, Codec, Decoder, Encoder } from '@solana/codecs-core';\n\n/** Defines a encoder for numbers and bigints. */\nexport type NumberEncoder = Encoder<number> | Encoder<number | bigint>;\n\n/** Defines a decoder for numbers and bigints. */\nexport type NumberDecoder = Decoder<number> | Decoder<bigint>;\n\n/** Defines a codec for numbers and bigints. */\nexport type NumberCodec = Codec<number> | Codec<number | bigint, bigint>;\n\n/** Defines the options for u8 and i8 codecs. */\nexport type SingleByteNumberCodecOptions = BaseCodecOptions;\n\n/** Defines the options for number codecs that use more than one byte. */\nexport type NumberCodecOptions = BaseCodecOptions & {\n    /**\n     * Whether the serializer should use little-endian or big-endian encoding.\n     * @defaultValue `Endian.LITTLE`\n     */\n    endian?: Endian;\n};\n\n/** Defines the endianness of a number serializer. */\nexport enum Endian {\n    LITTLE,\n    BIG,\n}\n","import { Codec, combineCodec, Decoder, Encoder } from '@solana/codecs-core';\n\nimport { NumberCodecOptions } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getF32Encoder = (options: NumberCodecOptions = {}): Encoder<number> =>\n    numberEncoderFactory({\n        name: 'f32',\n        options,\n        set: (view, value, le) => view.setFloat32(0, value, le),\n        size: 4,\n    });\n\nexport const getF32Decoder = (options: NumberCodecOptions = {}): Decoder<number> =>\n    numberDecoderFactory({\n        get: (view, le) => view.getFloat32(0, le),\n        name: 'f32',\n        options,\n        size: 4,\n    });\n\nexport const getF32Codec = (options: NumberCodecOptions = {}): Codec<number> =>\n    combineCodec(getF32Encoder(options), getF32Decoder(options));\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    CodecData,\n    Decoder,\n    Encoder,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\nimport { Endian, NumberCodecOptions, SingleByteNumberCodecOptions } from './common';\n\ntype NumberFactorySharedInput = {\n    name: string;\n    size: number;\n    options: SingleByteNumberCodecOptions | NumberCodecOptions;\n};\n\ntype NumberFactoryEncoderInput<T> = NumberFactorySharedInput & {\n    range?: [number | bigint, number | bigint];\n    set: (view: DataView, value: T, littleEndian?: boolean) => void;\n};\n\ntype NumberFactoryDecoderInput<T> = NumberFactorySharedInput & {\n    get: (view: DataView, littleEndian?: boolean) => T;\n};\n\nfunction sharedNumberFactory(input: NumberFactorySharedInput): CodecData & { littleEndian: boolean | undefined } {\n    let littleEndian: boolean | undefined;\n    let defaultDescription: string = input.name;\n\n    if (input.size > 1) {\n        littleEndian = !('endian' in input.options) || input.options.endian === Endian.LITTLE;\n        defaultDescription += littleEndian ? '(le)' : '(be)';\n    }\n\n    return {\n        description: input.options.description ?? defaultDescription,\n        fixedSize: input.size,\n        littleEndian,\n        maxSize: input.size,\n    };\n}\n\nexport function numberEncoderFactory<T extends number | bigint>(input: NumberFactoryEncoderInput<T>): Encoder<T> {\n    const codecData = sharedNumberFactory(input);\n\n    return {\n        description: codecData.description,\n        encode(value: T): Uint8Array {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, codecData.littleEndian);\n            return new Uint8Array(arrayBuffer);\n        },\n        fixedSize: codecData.fixedSize,\n        maxSize: codecData.maxSize,\n    };\n}\n\nexport function numberDecoderFactory<T extends number | bigint>(input: NumberFactoryDecoderInput<T>): Decoder<T> {\n    const codecData = sharedNumberFactory(input);\n\n    return {\n        decode(bytes, offset = 0): [T, number] {\n            assertByteArrayIsNotEmptyForCodec(codecData.description, bytes, offset);\n            assertByteArrayHasEnoughBytesForCodec(codecData.description, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [input.get(view, codecData.littleEndian), offset + input.size];\n        },\n        description: codecData.description,\n        fixedSize: codecData.fixedSize,\n        maxSize: codecData.maxSize,\n    };\n}\n\n/**\n * Helper function to ensure that the ArrayBuffer is converted properly from a Uint8Array\n * Source: https://stackoverflow.com/questions/37228285/uint8array-to-arraybuffer\n */\nfunction toArrayBuffer(bytes: Uint8Array, offset?: number, length?: number): ArrayBuffer {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n","import { Codec, combineCodec, Decoder, Encoder } from '@solana/codecs-core';\n\nimport { NumberCodecOptions } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getF64Encoder = (options: NumberCodecOptions = {}): Encoder<number> =>\n    numberEncoderFactory({\n        name: 'f64',\n        options,\n        set: (view, value, le) => view.setFloat64(0, value, le),\n        size: 8,\n    });\n\nexport const getF64Decoder = (options: NumberCodecOptions = {}): Decoder<number> =>\n    numberDecoderFactory({\n        get: (view, le) => view.getFloat64(0, le),\n        name: 'f64',\n        options,\n        size: 8,\n    });\n\nexport const getF64Codec = (options: NumberCodecOptions = {}): Codec<number> =>\n    combineCodec(getF64Encoder(options), getF64Decoder(options));\n","import { Codec, combineCodec, Decoder, Encoder } from '@solana/codecs-core';\n\nimport { NumberCodecOptions } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI128Encoder = (options: NumberCodecOptions = {}): Encoder<number | bigint> =>\n    numberEncoderFactory({\n        name: 'i128',\n        options,\n        range: [-BigInt('0x7fffffffffffffffffffffffffffffff') - 1n, BigInt('0x7fffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\nexport const getI128Decoder = (options: NumberCodecOptions = {}): Decoder<bigint> =>\n    numberDecoderFactory({\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'i128',\n        options,\n        size: 16,\n    });\n\nexport const getI128Codec = (options: NumberCodecOptions = {}): Codec<number | bigint, bigint> =>\n    combineCodec(getI128Encoder(options), getI128Decoder(options));\n","import { Codec, combineCodec, Decoder, Encoder } from '@solana/codecs-core';\n\nimport { NumberCodecOptions } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI16Encoder = (options: NumberCodecOptions = {}): Encoder<number> =>\n    numberEncoderFactory({\n        name: 'i16',\n        options,\n        range: [-Number('0x7fff') - 1, Number('0x7fff')],\n        set: (view, value, le) => view.setInt16(0, value, le),\n        size: 2,\n    });\n\nexport const getI16Decoder = (options: NumberCodecOptions = {}): Decoder<number> =>\n    numberDecoderFactory({\n        get: (view, le) => view.getInt16(0, le),\n        name: 'i16',\n        options,\n        size: 2,\n    });\n\nexport const getI16Codec = (options: NumberCodecOptions = {}): Codec<number> =>\n    combineCodec(getI16Encoder(options), getI16Decoder(options));\n","import { Codec, combineCodec, Decoder, Encoder } from '@solana/codecs-core';\n\nimport { NumberCodecOptions } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI32Encoder = (options: NumberCodecOptions = {}): Encoder<number> =>\n    numberEncoderFactory({\n        name: 'i32',\n        options,\n        range: [-Number('0x7fffffff') - 1, Number('0x7fffffff')],\n        set: (view, value, le) => view.setInt32(0, value, le),\n        size: 4,\n    });\n\nexport const getI32Decoder = (options: NumberCodecOptions = {}): Decoder<number> =>\n    numberDecoderFactory({\n        get: (view, le) => view.getInt32(0, le),\n        name: 'i32',\n        options,\n        size: 4,\n    });\n\nexport const getI32Codec = (options: NumberCodecOptions = {}): Codec<number> =>\n    combineCodec(getI32Encoder(options), getI32Decoder(options));\n","import { Codec, combineCodec, Decoder, Encoder } from '@solana/codecs-core';\n\nimport { NumberCodecOptions } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI64Encoder = (options: NumberCodecOptions = {}): Encoder<number | bigint> =>\n    numberEncoderFactory({\n        name: 'i64',\n        options,\n        range: [-BigInt('0x7fffffffffffffff') - 1n, BigInt('0x7fffffffffffffff')],\n        set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n        size: 8,\n    });\n\nexport const getI64Decoder = (options: NumberCodecOptions = {}): Decoder<bigint> =>\n    numberDecoderFactory({\n        get: (view, le) => view.getBigInt64(0, le),\n        name: 'i64',\n        options,\n        size: 8,\n    });\n\nexport const getI64Codec = (options: NumberCodecOptions = {}): Codec<number | bigint, bigint> =>\n    combineCodec(getI64Encoder(options), getI64Decoder(options));\n","import { Codec, combineCodec, Decoder, Encoder } from '@solana/codecs-core';\n\nimport { SingleByteNumberCodecOptions } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI8Encoder = (options: SingleByteNumberCodecOptions = {}): Encoder<number> =>\n    numberEncoderFactory({\n        name: 'i8',\n        options,\n        range: [-Number('0x7f') - 1, Number('0x7f')],\n        set: (view, value) => view.setInt8(0, value),\n        size: 1,\n    });\n\nexport const getI8Decoder = (options: SingleByteNumberCodecOptions = {}): Decoder<number> =>\n    numberDecoderFactory({\n        get: view => view.getInt8(0),\n        name: 'i8',\n        options,\n        size: 1,\n    });\n\nexport const getI8Codec = (options: SingleByteNumberCodecOptions = {}): Codec<number> =>\n    combineCodec(getI8Encoder(options), getI8Decoder(options));\n","import { BaseCodecOptions, Codec, combineCodec, Decoder, Encoder } from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\n\n/**\n * Defines the options for the shortU16 serializer.\n */\nexport type ShortU16CodecOptions = BaseCodecOptions;\n\n/**\n * Encodes short u16 numbers.\n * @see {@link getShortU16Codec} for a more detailed description.\n */\nexport const getShortU16Encoder = (options: ShortU16CodecOptions = {}): Encoder<number> => ({\n    description: options.description ?? 'shortU16',\n    encode: (value: number): Uint8Array => {\n        assertNumberIsBetweenForCodec('shortU16', 0, 65535, value);\n        const bytes = [0];\n        for (let ii = 0; ; ii += 1) {\n            // Shift the bits of the value over such that the next 7 bits are at the right edge.\n            const alignedValue = value >> (ii * 7);\n            if (alignedValue === 0) {\n                // No more bits to consume.\n                break;\n            }\n            // Extract those 7 bits using a mask.\n            const nextSevenBits = 0b1111111 & alignedValue;\n            bytes[ii] = nextSevenBits;\n            if (ii > 0) {\n                // Set the continuation bit of the previous slice.\n                bytes[ii - 1] |= 0b10000000;\n            }\n        }\n        return new Uint8Array(bytes);\n    },\n    fixedSize: null,\n    maxSize: 3,\n});\n\n/**\n * Decodes short u16 numbers.\n * @see {@link getShortU16Codec} for a more detailed description.\n */\nexport const getShortU16Decoder = (options: ShortU16CodecOptions = {}): Decoder<number> => ({\n    decode: (bytes: Uint8Array, offset = 0): [number, number] => {\n        let value = 0;\n        let byteCount = 0;\n        while (++byteCount) {\n            const byteIndex = byteCount - 1;\n            const currentByte = bytes[offset + byteIndex];\n            const nextSevenBits = 0b1111111 & currentByte;\n            // Insert the next group of seven bits into the correct slot of the output value.\n            value |= nextSevenBits << (byteIndex * 7);\n            if ((currentByte & 0b10000000) === 0) {\n                // This byte does not have its continuation bit set. We're done.\n                break;\n            }\n        }\n        return [value, offset + byteCount];\n    },\n    description: options.description ?? 'shortU16',\n    fixedSize: null,\n    maxSize: 3,\n});\n\n/**\n * Encodes and decodes short u16 numbers.\n *\n * Short u16 numbers are the same as u16, but serialized with 1 to 3 bytes.\n * If the value is above 0x7f, the top bit is set and the remaining\n * value is stored in the next bytes. Each byte follows the same\n * pattern until the 3rd byte. The 3rd byte, if needed, uses\n * all 8 bits to store the last byte of the original value.\n */\nexport const getShortU16Codec = (options: ShortU16CodecOptions = {}): Codec<number> =>\n    combineCodec(getShortU16Encoder(options), getShortU16Decoder(options));\n","import { Codec, combineCodec, Decoder, Encoder } from '@solana/codecs-core';\n\nimport { NumberCodecOptions } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU128Encoder = (options: NumberCodecOptions = {}): Encoder<number | bigint> =>\n    numberEncoderFactory({\n        name: 'u128',\n        options,\n        range: [0, BigInt('0xffffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\nexport const getU128Decoder = (options: NumberCodecOptions = {}): Decoder<bigint> =>\n    numberDecoderFactory({\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'u128',\n        options,\n        size: 16,\n    });\n\nexport const getU128Codec = (options: NumberCodecOptions = {}): Codec<number | bigint, bigint> =>\n    combineCodec(getU128Encoder(options), getU128Decoder(options));\n","import { Codec, combineCodec, Decoder, Encoder } from '@solana/codecs-core';\n\nimport { NumberCodecOptions } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU16Encoder = (options: NumberCodecOptions = {}): Encoder<number> =>\n    numberEncoderFactory({\n        name: 'u16',\n        options,\n        range: [0, Number('0xffff')],\n        set: (view, value, le) => view.setUint16(0, value, le),\n        size: 2,\n    });\n\nexport const getU16Decoder = (options: NumberCodecOptions = {}): Decoder<number> =>\n    numberDecoderFactory({\n        get: (view, le) => view.getUint16(0, le),\n        name: 'u16',\n        options,\n        size: 2,\n    });\n\nexport const getU16Codec = (options: NumberCodecOptions = {}): Codec<number> =>\n    combineCodec(getU16Encoder(options), getU16Decoder(options));\n","import { Codec, combineCodec, Decoder, Encoder } from '@solana/codecs-core';\n\nimport { NumberCodecOptions } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU32Encoder = (options: NumberCodecOptions = {}): Encoder<number> =>\n    numberEncoderFactory({\n        name: 'u32',\n        options,\n        range: [0, Number('0xffffffff')],\n        set: (view, value, le) => view.setUint32(0, value, le),\n        size: 4,\n    });\n\nexport const getU32Decoder = (options: NumberCodecOptions = {}): Decoder<number> =>\n    numberDecoderFactory({\n        get: (view, le) => view.getUint32(0, le),\n        name: 'u32',\n        options,\n        size: 4,\n    });\n\nexport const getU32Codec = (options: NumberCodecOptions = {}): Codec<number> =>\n    combineCodec(getU32Encoder(options), getU32Decoder(options));\n","import { Codec, combineCodec, Decoder, Encoder } from '@solana/codecs-core';\n\nimport { NumberCodecOptions } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU64Encoder = (options: NumberCodecOptions = {}): Encoder<number | bigint> =>\n    numberEncoderFactory({\n        name: 'u64',\n        options,\n        range: [0, BigInt('0xffffffffffffffff')],\n        set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n        size: 8,\n    });\n\nexport const getU64Decoder = (options: NumberCodecOptions = {}): Decoder<bigint> =>\n    numberDecoderFactory({\n        get: (view, le) => view.getBigUint64(0, le),\n        name: 'u64',\n        options,\n        size: 8,\n    });\n\nexport const getU64Codec = (options: NumberCodecOptions = {}): Codec<number | bigint, bigint> =>\n    combineCodec(getU64Encoder(options), getU64Decoder(options));\n","import { Codec, combineCodec, Decoder, Encoder } from '@solana/codecs-core';\n\nimport { SingleByteNumberCodecOptions } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU8Encoder = (options: SingleByteNumberCodecOptions = {}): Encoder<number> =>\n    numberEncoderFactory({\n        name: 'u8',\n        options,\n        range: [0, Number('0xff')],\n        set: (view, value) => view.setUint8(0, value),\n        size: 1,\n    });\n\nexport const getU8Decoder = (options: SingleByteNumberCodecOptions = {}): Decoder<number> =>\n    numberDecoderFactory({\n        get: view => view.getUint8(0),\n        name: 'u8',\n        options,\n        size: 1,\n    });\n\nexport const getU8Codec = (options: SingleByteNumberCodecOptions = {}): Codec<number> =>\n    combineCodec(getU8Encoder(options), getU8Decoder(options));\n"]}