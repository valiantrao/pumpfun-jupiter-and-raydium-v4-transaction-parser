{"version":3,"sources":["../src/assertions.ts","../src/baseX.ts","../src/base10.ts","../src/base16.ts","../src/base58.ts","../src/base64.ts","../src/baseX-reslice.ts","../src/null-characters.ts","../src/string.ts","../src/utf8.ts","../../text-encoding-impl/src/index.browser.ts"],"names":["alphabet","combineCodec","e","TextDecoder","TextEncoder"],"mappings":"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","sourcesContent":["/**\n * Asserts that a given string matches a given alphabet.\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        // TODO: Coded error.\n        throw new Error(`Expected a string of base ${alphabet.length}, got [${givenValue}].`);\n    }\n}\n","import { Codec, combineCodec, Decoder, Encoder } from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Encodes a string using a custom alphabet by dividing\n * by the base and handling leading zeroes.\n * @see {@link getBaseXCodec} for a more detailed description.\n */\nexport const getBaseXEncoder = (alphabet: string): Encoder<string> => {\n    const base = alphabet.length;\n    const baseBigInt = BigInt(base);\n    return {\n        description: `base${base}`,\n        encode(value: string): Uint8Array {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return new Uint8Array();\n\n            // Handle leading zeroes.\n            const chars = [...value];\n            let trailIndex = chars.findIndex(c => c !== alphabet[0]);\n            trailIndex = trailIndex === -1 ? chars.length : trailIndex;\n            const leadingZeroes = Array(trailIndex).fill(0);\n            if (trailIndex === chars.length) return Uint8Array.from(leadingZeroes);\n\n            // From baseX to base10.\n            const tailChars = chars.slice(trailIndex);\n            let base10Number = 0n;\n            let baseXPower = 1n;\n            for (let i = tailChars.length - 1; i >= 0; i -= 1) {\n                base10Number += baseXPower * BigInt(alphabet.indexOf(tailChars[i]));\n                baseXPower *= baseBigInt;\n            }\n\n            // From base10 to bytes.\n            const tailBytes = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n            return Uint8Array.from(leadingZeroes.concat(tailBytes));\n        },\n        fixedSize: null,\n        maxSize: null,\n    };\n};\n\n/**\n * Decodes a string using a custom alphabet by dividing\n * by the base and handling leading zeroes.\n * @see {@link getBaseXCodec} for a more detailed description.\n */\nexport const getBaseXDecoder = (alphabet: string): Decoder<string> => {\n    const base = alphabet.length;\n    const baseBigInt = BigInt(base);\n    return {\n        decode(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            let base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = [];\n            while (base10Number > 0n) {\n                tailChars.unshift(alphabet[Number(base10Number % baseBigInt)]);\n                base10Number /= baseBigInt;\n            }\n\n            return [leadingZeroes + tailChars.join(''), rawBytes.length];\n        },\n        description: `base${base}`,\n        fixedSize: null,\n        maxSize: null,\n    };\n};\n\n/**\n * A string codec that requires a custom alphabet and uses\n * the length of that alphabet as the base. It then divides\n * the input by the base as many times as necessary to get\n * the output. It also supports leading zeroes by using the\n * first character of the alphabet as the zero character.\n *\n * This can be used to create codecs such as base10 or base58.\n */\nexport const getBaseXCodec = (alphabet: string): Codec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/** Encodes strings in base10. */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/** Decodes strings in base10. */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/** Encodes and decodes strings in base10. */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import { Codec, combineCodec, Decoder, Encoder } from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/** Encodes strings in base16. */\nexport const getBase16Encoder = (): Encoder<string> => ({\n    description: 'base16',\n    encode(value: string) {\n        const lowercaseValue = value.toLowerCase();\n        assertValidBaseString('0123456789abcdef', lowercaseValue, value);\n        const matches = lowercaseValue.match(/.{1,2}/g);\n        return Uint8Array.from(matches ? matches.map((byte: string) => parseInt(byte, 16)) : []);\n    },\n    fixedSize: null,\n    maxSize: null,\n});\n\n/** Decodes strings in base16. */\nexport const getBase16Decoder = (): Decoder<string> => ({\n    decode(bytes, offset = 0) {\n        const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n        return [value, bytes.length];\n    },\n    description: 'base16',\n    fixedSize: null,\n    maxSize: null,\n});\n\n/** Encodes and decodes strings in base16. */\nexport const getBase16Codec = (): Codec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/** Encodes strings in base58. */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/** Decodes strings in base58. */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/** Encodes and decodes strings in base58. */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import { combineCodec, Decoder, Encoder, mapDecoder, mapEncoder } from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/** Encodes strings in base64. */\nexport const getBase64Encoder = (): Encoder<string> => {\n    if (__BROWSER__) {\n        return {\n            description: `base64`,\n            encode(value: string): Uint8Array {\n                try {\n                    const bytes = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    return new Uint8Array(bytes);\n                } catch (e) {\n                    // TODO: Coded error.\n                    throw new Error(`Expected a string of base 64, got [${value}].`);\n                }\n            },\n            fixedSize: null,\n            maxSize: null,\n        };\n    }\n\n    if (__NODEJS__) {\n        return {\n            description: `base64`,\n            encode(value: string): Uint8Array {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                return new Uint8Array(Buffer.from(value, 'base64'));\n            },\n            fixedSize: null,\n            maxSize: null,\n        };\n    }\n\n    return mapEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/** Decodes strings in base64. */\nexport const getBase64Decoder = (): Decoder<string> => {\n    if (__BROWSER__) {\n        return {\n            decode(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n            description: `base64`,\n            fixedSize: null,\n            maxSize: null,\n        };\n    }\n\n    if (__NODEJS__) {\n        return {\n            decode: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n            description: `base64`,\n            fixedSize: null,\n            maxSize: null,\n        };\n    }\n\n    return mapDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '=')\n    );\n};\n\n/** Encodes and decodes strings in base64. */\nexport const getBase64Codec = () => combineCodec(getBase64Encoder(), getBase64Decoder());\n","import { Codec, combineCodec, Decoder, Encoder } from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Encodes a string using a custom alphabet by reslicing the bits of the byte array.\n * @see {@link getBaseXResliceCodec} for a more detailed description.\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): Encoder<string> => ({\n    description: `base${alphabet.length}`,\n    encode(value: string): Uint8Array {\n        assertValidBaseString(alphabet, value);\n        if (value === '') return new Uint8Array();\n        const charIndices = [...value].map(c => alphabet.indexOf(c));\n        return new Uint8Array(reslice(charIndices, bits, 8, false));\n    },\n    fixedSize: null,\n    maxSize: null,\n});\n\n/**\n * Decodes a string using a custom alphabet by reslicing the bits of the byte array.\n * @see {@link getBaseXResliceCodec} for a more detailed description.\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): Decoder<string> => ({\n    decode(rawBytes, offset = 0): [string, number] {\n        const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n        if (bytes.length === 0) return ['', rawBytes.length];\n        const charIndices = reslice([...bytes], 8, bits, true);\n        return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n    },\n    description: `base${alphabet.length}`,\n    fixedSize: null,\n    maxSize: null,\n});\n\n/**\n * A string serializer that reslices bytes into custom chunks\n * of bits that are then mapped to a custom alphabet.\n *\n * This can be used to create serializers whose alphabet\n * is a power of 2 such as base16 or base64.\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): Codec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","/**Removes null characters from a string. */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/** Pads a string with null characters at the end. */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    BaseCodecOptions,\n    Codec,\n    CodecData,\n    combineCodec,\n    Decoder,\n    Encoder,\n    fixDecoder,\n    fixEncoder,\n    mergeBytes,\n} from '@solana/codecs-core';\nimport { getU32Decoder, getU32Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { getUtf8Decoder, getUtf8Encoder } from './utf8';\n\n/** Defines the options for string codecs. */\nexport type StringCodecOptions<\n    TPrefix extends NumberCodec | NumberEncoder | NumberDecoder,\n    TEncoding extends Codec<string> | Encoder<string> | Decoder<string>\n> = BaseCodecOptions & {\n    /**\n     * The size of the string. It can be one of the following:\n     * - a {@link NumberCodec} that prefixes the string with its size.\n     * - a fixed number of bytes.\n     * - or `'variable'` to use the rest of the byte array.\n     * @defaultValue u32 prefix.\n     */\n    size?: TPrefix | number | 'variable';\n\n    /**\n     * The codec to use for encoding and decoding the content.\n     * @defaultValue UTF-8 encoding.\n     */\n    encoding?: TEncoding;\n};\n\n/** Encodes strings from a given encoding and size strategy. */\nexport const getStringEncoder = (options: StringCodecOptions<NumberEncoder, Encoder<string>> = {}): Encoder<string> => {\n    const size = options.size ?? getU32Encoder();\n    const encoding = options.encoding ?? getUtf8Encoder();\n    const description = options.description ?? `string(${encoding.description}; ${getSizeDescription(size)})`;\n\n    if (size === 'variable') {\n        return { ...encoding, description };\n    }\n\n    if (typeof size === 'number') {\n        return fixEncoder(encoding, size, description);\n    }\n\n    return {\n        description,\n        encode: (value: string) => {\n            const contentBytes = encoding.encode(value);\n            const lengthBytes = size.encode(contentBytes.length);\n            return mergeBytes([lengthBytes, contentBytes]);\n        },\n        fixedSize: null,\n        maxSize: null,\n    };\n};\n\n/** Decodes strings from a given encoding and size strategy. */\nexport const getStringDecoder = (options: StringCodecOptions<NumberDecoder, Decoder<string>> = {}): Decoder<string> => {\n    const size = options.size ?? getU32Decoder();\n    const encoding = options.encoding ?? getUtf8Decoder();\n    const description = options.description ?? `string(${encoding.description}; ${getSizeDescription(size)})`;\n\n    if (size === 'variable') {\n        return { ...encoding, description };\n    }\n\n    if (typeof size === 'number') {\n        return fixDecoder(encoding, size, description);\n    }\n\n    return {\n        decode: (bytes: Uint8Array, offset = 0) => {\n            assertByteArrayIsNotEmptyForCodec('string', bytes, offset);\n            const [lengthBigInt, lengthOffset] = size.decode(bytes, offset);\n            const length = Number(lengthBigInt);\n            offset = lengthOffset;\n            const contentBytes = bytes.slice(offset, offset + length);\n            assertByteArrayHasEnoughBytesForCodec('string', length, contentBytes);\n            const [value, contentOffset] = encoding.decode(contentBytes);\n            offset += contentOffset;\n            return [value, offset];\n        },\n        description,\n        fixedSize: null,\n        maxSize: null,\n    };\n};\n\n/** Encodes and decodes strings from a given encoding and size strategy. */\nexport const getStringCodec = (options: StringCodecOptions<NumberCodec, Codec<string>> = {}): Codec<string> =>\n    combineCodec(getStringEncoder(options), getStringDecoder(options));\n\nfunction getSizeDescription(size: CodecData | number | 'variable'): string {\n    return typeof size === 'object' ? size.description : `${size}`;\n}\n","import { Codec, combineCodec, Decoder, Encoder } from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from 'text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/** Encodes UTF-8 strings using the native `TextEncoder` API. */\nexport const getUtf8Encoder = (): Encoder<string> => {\n    let textEncoder: TextEncoder;\n    return {\n        description: 'utf8',\n        encode: (value: string) => new Uint8Array((textEncoder ||= new TextEncoder()).encode(value)),\n        fixedSize: null,\n        maxSize: null,\n    };\n};\n\n/** Decodes UTF-8 strings using the native `TextDecoder` API. */\nexport const getUtf8Decoder = (): Decoder<string> => {\n    let textDecoder: TextDecoder;\n    return {\n        decode(bytes, offset = 0) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n        description: 'utf8',\n        fixedSize: null,\n        maxSize: null,\n    };\n};\n\n/** Encodes and decodes UTF-8 strings using the native `TextEncoder` and `TextDecoder` API. */\nexport const getUtf8Codec = (): Codec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n"]}