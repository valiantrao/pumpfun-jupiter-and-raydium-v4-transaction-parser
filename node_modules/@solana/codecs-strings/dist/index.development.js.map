{"version":3,"sources":["../src/assertions.ts","../../codecs-core/src/assertions.ts","../../codecs-core/src/bytes.ts","../../codecs-core/src/combine-codec.ts","../../codecs-core/src/fix-codec.ts","../../codecs-core/src/map-codec.ts","../src/baseX.ts","../src/base10.ts","../src/base16.ts","../src/base58.ts","../src/baseX-reslice.ts","../src/base64.ts","../src/null-characters.ts","../../codecs-numbers/dist/index.browser.js","../../text-encoding-impl/src/index.browser.ts","../src/utf8.ts","../src/string.ts"],"names":["alphabet","e","TextDecoder","TextEncoder"],"mappings":"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","sourcesContent":["/**\n * Asserts that a given string matches a given alphabet.\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        // TODO: Coded error.\n        throw new Error(`Expected a string of base ${alphabet.length}, got [${givenValue}].`);\n    }\n}\n","import { CodecData } from './codec';\n\n/**\n * Asserts that a given byte array is not empty.\n */\nexport function assertByteArrayIsNotEmptyForCodec(codecDescription: string, bytes: Uint8Array, offset = 0) {\n    if (bytes.length - offset <= 0) {\n        // TODO: Coded error.\n        throw new Error(`Codec [${codecDescription}] cannot decode empty byte arrays.`);\n    }\n}\n\n/**\n * Asserts that a given byte array has enough bytes to decode.\n */\nexport function assertByteArrayHasEnoughBytesForCodec(\n    codecDescription: string,\n    expected: number,\n    bytes: Uint8Array,\n    offset = 0\n) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        // TODO: Coded error.\n        throw new Error(`Codec [${codecDescription}] expected ${expected} bytes, got ${bytesLength}.`);\n    }\n}\n\n/**\n * Asserts that a given codec is fixed-size codec.\n */\nexport function assertFixedSizeCodec(\n    data: Pick<CodecData, 'fixedSize'>,\n    message?: string\n): asserts data is { fixedSize: number } {\n    if (data.fixedSize === null) {\n        // TODO: Coded error.\n        throw new Error(message ?? 'Expected a fixed-size codec, got a variable-size one.');\n    }\n}\n","/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n */\nexport const padBytes = (bytes: Uint8Array, length: number): Uint8Array => {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n */\nexport const fixBytes = (bytes: Uint8Array, length: number): Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n","import { Codec, Decoder, Encoder } from './codec';\n\n/**\n * Combines an encoder and a decoder into a codec.\n * The encoder and decoder must have the same fixed size, max size and description.\n * If a description is provided, it will override the encoder and decoder descriptions.\n */\nexport function combineCodec<From, To extends From = From>(\n    encoder: Encoder<From>,\n    decoder: Decoder<To>,\n    description?: string\n): Codec<From, To> {\n    if (encoder.fixedSize !== decoder.fixedSize) {\n        // TODO: Coded error.\n        throw new Error(\n            `Encoder and decoder must have the same fixed size, got [${encoder.fixedSize}] and [${decoder.fixedSize}].`\n        );\n    }\n\n    if (encoder.maxSize !== decoder.maxSize) {\n        // TODO: Coded error.\n        throw new Error(\n            `Encoder and decoder must have the same max size, got [${encoder.maxSize}] and [${decoder.maxSize}].`\n        );\n    }\n\n    if (description === undefined && encoder.description !== decoder.description) {\n        // TODO: Coded error.\n        throw new Error(\n            `Encoder and decoder must have the same description, got [${encoder.description}] and [${decoder.description}]. ` +\n                `Pass a custom description as a third argument if you want to override the description and bypass this error.`\n        );\n    }\n\n    return {\n        decode: decoder.decode,\n        description: description ?? encoder.description,\n        encode: encoder.encode,\n        fixedSize: encoder.fixedSize,\n        maxSize: encoder.maxSize,\n    };\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport { fixBytes } from './bytes';\nimport { Codec, CodecData, Decoder, Encoder } from './codec';\nimport { combineCodec } from './combine-codec';\n\nfunction fixCodecHelper(data: CodecData, fixedBytes: number, description?: string): CodecData {\n    return {\n        description: description ?? `fixed(${fixedBytes}, ${data.description})`,\n        fixedSize: fixedBytes,\n        maxSize: fixedBytes,\n    };\n}\n\n/**\n * Creates a fixed-size encoder from a given encoder.\n *\n * @param encoder - The encoder to wrap into a fixed-size encoder.\n * @param fixedBytes - The fixed number of bytes to write.\n * @param description - A custom description for the encoder.\n */\nexport function fixEncoder<T>(encoder: Encoder<T>, fixedBytes: number, description?: string): Encoder<T> {\n    return {\n        ...fixCodecHelper(encoder, fixedBytes, description),\n        encode: (value: T) => fixBytes(encoder.encode(value), fixedBytes),\n    };\n}\n\n/**\n * Creates a fixed-size decoder from a given decoder.\n *\n * @param decoder - The decoder to wrap into a fixed-size decoder.\n * @param fixedBytes - The fixed number of bytes to read.\n * @param description - A custom description for the decoder.\n */\nexport function fixDecoder<T>(decoder: Decoder<T>, fixedBytes: number, description?: string): Decoder<T> {\n    return {\n        ...fixCodecHelper(decoder, fixedBytes, description),\n        decode: (bytes: Uint8Array, offset = 0) => {\n            assertByteArrayHasEnoughBytesForCodec('fixCodec', fixedBytes, bytes, offset);\n            // Slice the byte array to the fixed size if necessary.\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            // If the nested decoder is fixed-size, pad and truncate the byte array accordingly.\n            if (decoder.fixedSize !== null) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            // Decode the value using the nested decoder.\n            const [value] = decoder.decode(bytes, 0);\n            return [value, offset + fixedBytes];\n        },\n    };\n}\n\n/**\n * Creates a fixed-size codec from a given codec.\n *\n * @param codec - The codec to wrap into a fixed-size codec.\n * @param fixedBytes - The fixed number of bytes to read/write.\n * @param description - A custom description for the codec.\n */\nexport function fixCodec<T, U extends T = T>(\n    codec: Codec<T, U>,\n    fixedBytes: number,\n    description?: string\n): Codec<T, U> {\n    return combineCodec(fixEncoder(codec, fixedBytes, description), fixDecoder(codec, fixedBytes, description));\n}\n","import { Codec, Decoder, Encoder } from './codec';\n\n/**\n * Converts an encoder A to a encoder B by mapping their values.\n */\nexport function mapEncoder<T, U>(encoder: Encoder<T>, unmap: (value: U) => T): Encoder<U> {\n    return {\n        description: encoder.description,\n        encode: (value: U) => encoder.encode(unmap(value)),\n        fixedSize: encoder.fixedSize,\n        maxSize: encoder.maxSize,\n    };\n}\n\n/**\n * Converts an decoder A to a decoder B by mapping their values.\n */\nexport function mapDecoder<T, U>(\n    decoder: Decoder<T>,\n    map: (value: T, bytes: Uint8Array, offset: number) => U\n): Decoder<U> {\n    return {\n        decode: (bytes: Uint8Array, offset = 0) => {\n            const [value, length] = decoder.decode(bytes, offset);\n            return [map(value, bytes, offset), length];\n        },\n        description: decoder.description,\n        fixedSize: decoder.fixedSize,\n        maxSize: decoder.maxSize,\n    };\n}\n\n/**\n * Converts a codec A to a codec B by mapping their values.\n */\nexport function mapCodec<NewFrom, OldFrom, To extends NewFrom & OldFrom>(\n    codec: Codec<OldFrom, To>,\n    unmap: (value: NewFrom) => OldFrom\n): Codec<NewFrom, To>;\nexport function mapCodec<NewFrom, OldFrom, NewTo extends NewFrom = NewFrom, OldTo extends OldFrom = OldFrom>(\n    codec: Codec<OldFrom, OldTo>,\n    unmap: (value: NewFrom) => OldFrom,\n    map: (value: OldTo, bytes: Uint8Array, offset: number) => NewTo\n): Codec<NewFrom, NewTo>;\nexport function mapCodec<NewFrom, OldFrom, NewTo extends NewFrom = NewFrom, OldTo extends OldFrom = OldFrom>(\n    codec: Codec<OldFrom, OldTo>,\n    unmap: (value: NewFrom) => OldFrom,\n    map?: (value: OldTo, bytes: Uint8Array, offset: number) => NewTo\n): Codec<NewFrom, NewTo> {\n    return {\n        decode: map ? mapDecoder(codec, map).decode : (codec.decode as unknown as Decoder<NewTo>['decode']),\n        description: codec.description,\n        encode: mapEncoder(codec, unmap).encode,\n        fixedSize: codec.fixedSize,\n        maxSize: codec.maxSize,\n    };\n}\n","import { Codec, combineCodec, Decoder, Encoder } from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Encodes a string using a custom alphabet by dividing\n * by the base and handling leading zeroes.\n * @see {@link getBaseXCodec} for a more detailed description.\n */\nexport const getBaseXEncoder = (alphabet: string): Encoder<string> => {\n    const base = alphabet.length;\n    const baseBigInt = BigInt(base);\n    return {\n        description: `base${base}`,\n        encode(value: string): Uint8Array {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return new Uint8Array();\n\n            // Handle leading zeroes.\n            const chars = [...value];\n            let trailIndex = chars.findIndex(c => c !== alphabet[0]);\n            trailIndex = trailIndex === -1 ? chars.length : trailIndex;\n            const leadingZeroes = Array(trailIndex).fill(0);\n            if (trailIndex === chars.length) return Uint8Array.from(leadingZeroes);\n\n            // From baseX to base10.\n            const tailChars = chars.slice(trailIndex);\n            let base10Number = 0n;\n            let baseXPower = 1n;\n            for (let i = tailChars.length - 1; i >= 0; i -= 1) {\n                base10Number += baseXPower * BigInt(alphabet.indexOf(tailChars[i]));\n                baseXPower *= baseBigInt;\n            }\n\n            // From base10 to bytes.\n            const tailBytes = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n            return Uint8Array.from(leadingZeroes.concat(tailBytes));\n        },\n        fixedSize: null,\n        maxSize: null,\n    };\n};\n\n/**\n * Decodes a string using a custom alphabet by dividing\n * by the base and handling leading zeroes.\n * @see {@link getBaseXCodec} for a more detailed description.\n */\nexport const getBaseXDecoder = (alphabet: string): Decoder<string> => {\n    const base = alphabet.length;\n    const baseBigInt = BigInt(base);\n    return {\n        decode(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            let base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = [];\n            while (base10Number > 0n) {\n                tailChars.unshift(alphabet[Number(base10Number % baseBigInt)]);\n                base10Number /= baseBigInt;\n            }\n\n            return [leadingZeroes + tailChars.join(''), rawBytes.length];\n        },\n        description: `base${base}`,\n        fixedSize: null,\n        maxSize: null,\n    };\n};\n\n/**\n * A string codec that requires a custom alphabet and uses\n * the length of that alphabet as the base. It then divides\n * the input by the base as many times as necessary to get\n * the output. It also supports leading zeroes by using the\n * first character of the alphabet as the zero character.\n *\n * This can be used to create codecs such as base10 or base58.\n */\nexport const getBaseXCodec = (alphabet: string): Codec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/** Encodes strings in base10. */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/** Decodes strings in base10. */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/** Encodes and decodes strings in base10. */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import { Codec, combineCodec, Decoder, Encoder } from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/** Encodes strings in base16. */\nexport const getBase16Encoder = (): Encoder<string> => ({\n    description: 'base16',\n    encode(value: string) {\n        const lowercaseValue = value.toLowerCase();\n        assertValidBaseString('0123456789abcdef', lowercaseValue, value);\n        const matches = lowercaseValue.match(/.{1,2}/g);\n        return Uint8Array.from(matches ? matches.map((byte: string) => parseInt(byte, 16)) : []);\n    },\n    fixedSize: null,\n    maxSize: null,\n});\n\n/** Decodes strings in base16. */\nexport const getBase16Decoder = (): Decoder<string> => ({\n    decode(bytes, offset = 0) {\n        const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n        return [value, bytes.length];\n    },\n    description: 'base16',\n    fixedSize: null,\n    maxSize: null,\n});\n\n/** Encodes and decodes strings in base16. */\nexport const getBase16Codec = (): Codec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/** Encodes strings in base58. */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/** Decodes strings in base58. */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/** Encodes and decodes strings in base58. */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import { Codec, combineCodec, Decoder, Encoder } from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Encodes a string using a custom alphabet by reslicing the bits of the byte array.\n * @see {@link getBaseXResliceCodec} for a more detailed description.\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): Encoder<string> => ({\n    description: `base${alphabet.length}`,\n    encode(value: string): Uint8Array {\n        assertValidBaseString(alphabet, value);\n        if (value === '') return new Uint8Array();\n        const charIndices = [...value].map(c => alphabet.indexOf(c));\n        return new Uint8Array(reslice(charIndices, bits, 8, false));\n    },\n    fixedSize: null,\n    maxSize: null,\n});\n\n/**\n * Decodes a string using a custom alphabet by reslicing the bits of the byte array.\n * @see {@link getBaseXResliceCodec} for a more detailed description.\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): Decoder<string> => ({\n    decode(rawBytes, offset = 0): [string, number] {\n        const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n        if (bytes.length === 0) return ['', rawBytes.length];\n        const charIndices = reslice([...bytes], 8, bits, true);\n        return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n    },\n    description: `base${alphabet.length}`,\n    fixedSize: null,\n    maxSize: null,\n});\n\n/**\n * A string serializer that reslices bytes into custom chunks\n * of bits that are then mapped to a custom alphabet.\n *\n * This can be used to create serializers whose alphabet\n * is a power of 2 such as base16 or base64.\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): Codec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","import { combineCodec, Decoder, Encoder, mapDecoder, mapEncoder } from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/** Encodes strings in base64. */\nexport const getBase64Encoder = (): Encoder<string> => {\n    if (__BROWSER__) {\n        return {\n            description: `base64`,\n            encode(value: string): Uint8Array {\n                try {\n                    const bytes = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    return new Uint8Array(bytes);\n                } catch (e) {\n                    // TODO: Coded error.\n                    throw new Error(`Expected a string of base 64, got [${value}].`);\n                }\n            },\n            fixedSize: null,\n            maxSize: null,\n        };\n    }\n\n    if (__NODEJS__) {\n        return {\n            description: `base64`,\n            encode(value: string): Uint8Array {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                return new Uint8Array(Buffer.from(value, 'base64'));\n            },\n            fixedSize: null,\n            maxSize: null,\n        };\n    }\n\n    return mapEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/** Decodes strings in base64. */\nexport const getBase64Decoder = (): Decoder<string> => {\n    if (__BROWSER__) {\n        return {\n            decode(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n            description: `base64`,\n            fixedSize: null,\n            maxSize: null,\n        };\n    }\n\n    if (__NODEJS__) {\n        return {\n            decode: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n            description: `base64`,\n            fixedSize: null,\n            maxSize: null,\n        };\n    }\n\n    return mapDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '=')\n    );\n};\n\n/** Encodes and decodes strings in base64. */\nexport const getBase64Codec = () => combineCodec(getBase64Encoder(), getBase64Decoder());\n","/**Removes null characters from a string. */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/** Pads a string with null characters at the end. */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","import { combineCodec, assertByteArrayIsNotEmptyForCodec, assertByteArrayHasEnoughBytesForCodec } from '@solana/codecs-core';\n\n// src/assertions.ts\nfunction assertNumberIsBetweenForCodec(codecDescription, min, max, value) {\n  if (value < min || value > max) {\n    throw new Error(\n      `Codec [${codecDescription}] expected number to be in the range [${min}, ${max}], got ${value}.`\n    );\n  }\n}\n\n// src/common.ts\nvar Endian = /* @__PURE__ */ ((Endian2) => {\n  Endian2[Endian2[\"LITTLE\"] = 0] = \"LITTLE\";\n  Endian2[Endian2[\"BIG\"] = 1] = \"BIG\";\n  return Endian2;\n})(Endian || {});\nfunction sharedNumberFactory(input) {\n  let littleEndian;\n  let defaultDescription = input.name;\n  if (input.size > 1) {\n    littleEndian = !(\"endian\" in input.options) || input.options.endian === 0 /* LITTLE */;\n    defaultDescription += littleEndian ? \"(le)\" : \"(be)\";\n  }\n  return {\n    description: input.options.description ?? defaultDescription,\n    fixedSize: input.size,\n    littleEndian,\n    maxSize: input.size\n  };\n}\nfunction numberEncoderFactory(input) {\n  const codecData = sharedNumberFactory(input);\n  return {\n    description: codecData.description,\n    encode(value) {\n      if (input.range) {\n        assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n      }\n      const arrayBuffer = new ArrayBuffer(input.size);\n      input.set(new DataView(arrayBuffer), value, codecData.littleEndian);\n      return new Uint8Array(arrayBuffer);\n    },\n    fixedSize: codecData.fixedSize,\n    maxSize: codecData.maxSize\n  };\n}\nfunction numberDecoderFactory(input) {\n  const codecData = sharedNumberFactory(input);\n  return {\n    decode(bytes, offset = 0) {\n      assertByteArrayIsNotEmptyForCodec(codecData.description, bytes, offset);\n      assertByteArrayHasEnoughBytesForCodec(codecData.description, input.size, bytes, offset);\n      const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n      return [input.get(view, codecData.littleEndian), offset + input.size];\n    },\n    description: codecData.description,\n    fixedSize: codecData.fixedSize,\n    maxSize: codecData.maxSize\n  };\n}\nfunction toArrayBuffer(bytes, offset, length) {\n  const bytesOffset = bytes.byteOffset + (offset ?? 0);\n  const bytesLength = length ?? bytes.byteLength;\n  return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n\n// src/f32.ts\nvar getF32Encoder = (options = {}) => numberEncoderFactory({\n  name: \"f32\",\n  options,\n  set: (view, value, le) => view.setFloat32(0, value, le),\n  size: 4\n});\nvar getF32Decoder = (options = {}) => numberDecoderFactory({\n  get: (view, le) => view.getFloat32(0, le),\n  name: \"f32\",\n  options,\n  size: 4\n});\nvar getF32Codec = (options = {}) => combineCodec(getF32Encoder(options), getF32Decoder(options));\nvar getF64Encoder = (options = {}) => numberEncoderFactory({\n  name: \"f64\",\n  options,\n  set: (view, value, le) => view.setFloat64(0, value, le),\n  size: 8\n});\nvar getF64Decoder = (options = {}) => numberDecoderFactory({\n  get: (view, le) => view.getFloat64(0, le),\n  name: \"f64\",\n  options,\n  size: 8\n});\nvar getF64Codec = (options = {}) => combineCodec(getF64Encoder(options), getF64Decoder(options));\nvar getI128Encoder = (options = {}) => numberEncoderFactory({\n  name: \"i128\",\n  options,\n  range: [-BigInt(\"0x7fffffffffffffffffffffffffffffff\") - 1n, BigInt(\"0x7fffffffffffffffffffffffffffffff\")],\n  set: (view, value, le) => {\n    const leftOffset = le ? 8 : 0;\n    const rightOffset = le ? 0 : 8;\n    const rightMask = 0xffffffffffffffffn;\n    view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n    view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n  },\n  size: 16\n});\nvar getI128Decoder = (options = {}) => numberDecoderFactory({\n  get: (view, le) => {\n    const leftOffset = le ? 8 : 0;\n    const rightOffset = le ? 0 : 8;\n    const left = view.getBigInt64(leftOffset, le);\n    const right = view.getBigUint64(rightOffset, le);\n    return (left << 64n) + right;\n  },\n  name: \"i128\",\n  options,\n  size: 16\n});\nvar getI128Codec = (options = {}) => combineCodec(getI128Encoder(options), getI128Decoder(options));\nvar getI16Encoder = (options = {}) => numberEncoderFactory({\n  name: \"i16\",\n  options,\n  range: [-Number(\"0x7fff\") - 1, Number(\"0x7fff\")],\n  set: (view, value, le) => view.setInt16(0, value, le),\n  size: 2\n});\nvar getI16Decoder = (options = {}) => numberDecoderFactory({\n  get: (view, le) => view.getInt16(0, le),\n  name: \"i16\",\n  options,\n  size: 2\n});\nvar getI16Codec = (options = {}) => combineCodec(getI16Encoder(options), getI16Decoder(options));\nvar getI32Encoder = (options = {}) => numberEncoderFactory({\n  name: \"i32\",\n  options,\n  range: [-Number(\"0x7fffffff\") - 1, Number(\"0x7fffffff\")],\n  set: (view, value, le) => view.setInt32(0, value, le),\n  size: 4\n});\nvar getI32Decoder = (options = {}) => numberDecoderFactory({\n  get: (view, le) => view.getInt32(0, le),\n  name: \"i32\",\n  options,\n  size: 4\n});\nvar getI32Codec = (options = {}) => combineCodec(getI32Encoder(options), getI32Decoder(options));\nvar getI64Encoder = (options = {}) => numberEncoderFactory({\n  name: \"i64\",\n  options,\n  range: [-BigInt(\"0x7fffffffffffffff\") - 1n, BigInt(\"0x7fffffffffffffff\")],\n  set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n  size: 8\n});\nvar getI64Decoder = (options = {}) => numberDecoderFactory({\n  get: (view, le) => view.getBigInt64(0, le),\n  name: \"i64\",\n  options,\n  size: 8\n});\nvar getI64Codec = (options = {}) => combineCodec(getI64Encoder(options), getI64Decoder(options));\nvar getI8Encoder = (options = {}) => numberEncoderFactory({\n  name: \"i8\",\n  options,\n  range: [-Number(\"0x7f\") - 1, Number(\"0x7f\")],\n  set: (view, value) => view.setInt8(0, value),\n  size: 1\n});\nvar getI8Decoder = (options = {}) => numberDecoderFactory({\n  get: (view) => view.getInt8(0),\n  name: \"i8\",\n  options,\n  size: 1\n});\nvar getI8Codec = (options = {}) => combineCodec(getI8Encoder(options), getI8Decoder(options));\nvar getShortU16Encoder = (options = {}) => ({\n  description: options.description ?? \"shortU16\",\n  encode: (value) => {\n    assertNumberIsBetweenForCodec(\"shortU16\", 0, 65535, value);\n    const bytes = [0];\n    for (let ii = 0; ; ii += 1) {\n      const alignedValue = value >> ii * 7;\n      if (alignedValue === 0) {\n        break;\n      }\n      const nextSevenBits = 127 & alignedValue;\n      bytes[ii] = nextSevenBits;\n      if (ii > 0) {\n        bytes[ii - 1] |= 128;\n      }\n    }\n    return new Uint8Array(bytes);\n  },\n  fixedSize: null,\n  maxSize: 3\n});\nvar getShortU16Decoder = (options = {}) => ({\n  decode: (bytes, offset = 0) => {\n    let value = 0;\n    let byteCount = 0;\n    while (++byteCount) {\n      const byteIndex = byteCount - 1;\n      const currentByte = bytes[offset + byteIndex];\n      const nextSevenBits = 127 & currentByte;\n      value |= nextSevenBits << byteIndex * 7;\n      if ((currentByte & 128) === 0) {\n        break;\n      }\n    }\n    return [value, offset + byteCount];\n  },\n  description: options.description ?? \"shortU16\",\n  fixedSize: null,\n  maxSize: 3\n});\nvar getShortU16Codec = (options = {}) => combineCodec(getShortU16Encoder(options), getShortU16Decoder(options));\nvar getU128Encoder = (options = {}) => numberEncoderFactory({\n  name: \"u128\",\n  options,\n  range: [0, BigInt(\"0xffffffffffffffffffffffffffffffff\")],\n  set: (view, value, le) => {\n    const leftOffset = le ? 8 : 0;\n    const rightOffset = le ? 0 : 8;\n    const rightMask = 0xffffffffffffffffn;\n    view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n    view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n  },\n  size: 16\n});\nvar getU128Decoder = (options = {}) => numberDecoderFactory({\n  get: (view, le) => {\n    const leftOffset = le ? 8 : 0;\n    const rightOffset = le ? 0 : 8;\n    const left = view.getBigUint64(leftOffset, le);\n    const right = view.getBigUint64(rightOffset, le);\n    return (left << 64n) + right;\n  },\n  name: \"u128\",\n  options,\n  size: 16\n});\nvar getU128Codec = (options = {}) => combineCodec(getU128Encoder(options), getU128Decoder(options));\nvar getU16Encoder = (options = {}) => numberEncoderFactory({\n  name: \"u16\",\n  options,\n  range: [0, Number(\"0xffff\")],\n  set: (view, value, le) => view.setUint16(0, value, le),\n  size: 2\n});\nvar getU16Decoder = (options = {}) => numberDecoderFactory({\n  get: (view, le) => view.getUint16(0, le),\n  name: \"u16\",\n  options,\n  size: 2\n});\nvar getU16Codec = (options = {}) => combineCodec(getU16Encoder(options), getU16Decoder(options));\nvar getU32Encoder = (options = {}) => numberEncoderFactory({\n  name: \"u32\",\n  options,\n  range: [0, Number(\"0xffffffff\")],\n  set: (view, value, le) => view.setUint32(0, value, le),\n  size: 4\n});\nvar getU32Decoder = (options = {}) => numberDecoderFactory({\n  get: (view, le) => view.getUint32(0, le),\n  name: \"u32\",\n  options,\n  size: 4\n});\nvar getU32Codec = (options = {}) => combineCodec(getU32Encoder(options), getU32Decoder(options));\nvar getU64Encoder = (options = {}) => numberEncoderFactory({\n  name: \"u64\",\n  options,\n  range: [0, BigInt(\"0xffffffffffffffff\")],\n  set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n  size: 8\n});\nvar getU64Decoder = (options = {}) => numberDecoderFactory({\n  get: (view, le) => view.getBigUint64(0, le),\n  name: \"u64\",\n  options,\n  size: 8\n});\nvar getU64Codec = (options = {}) => combineCodec(getU64Encoder(options), getU64Decoder(options));\nvar getU8Encoder = (options = {}) => numberEncoderFactory({\n  name: \"u8\",\n  options,\n  range: [0, Number(\"0xff\")],\n  set: (view, value) => view.setUint8(0, value),\n  size: 1\n});\nvar getU8Decoder = (options = {}) => numberDecoderFactory({\n  get: (view) => view.getUint8(0),\n  name: \"u8\",\n  options,\n  size: 1\n});\nvar getU8Codec = (options = {}) => combineCodec(getU8Encoder(options), getU8Decoder(options));\n\nexport { Endian, assertNumberIsBetweenForCodec, getF32Codec, getF32Decoder, getF32Encoder, getF64Codec, getF64Decoder, getF64Encoder, getI128Codec, getI128Decoder, getI128Encoder, getI16Codec, getI16Decoder, getI16Encoder, getI32Codec, getI32Decoder, getI32Encoder, getI64Codec, getI64Decoder, getI64Encoder, getI8Codec, getI8Decoder, getI8Encoder, getShortU16Codec, getShortU16Decoder, getShortU16Encoder, getU128Codec, getU128Decoder, getU128Encoder, getU16Codec, getU16Decoder, getU16Encoder, getU32Codec, getU32Decoder, getU32Encoder, getU64Codec, getU64Decoder, getU64Encoder, getU8Codec, getU8Decoder, getU8Encoder };\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import { Codec, combineCodec, Decoder, Encoder } from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from 'text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/** Encodes UTF-8 strings using the native `TextEncoder` API. */\nexport const getUtf8Encoder = (): Encoder<string> => {\n    let textEncoder: TextEncoder;\n    return {\n        description: 'utf8',\n        encode: (value: string) => new Uint8Array((textEncoder ||= new TextEncoder()).encode(value)),\n        fixedSize: null,\n        maxSize: null,\n    };\n};\n\n/** Decodes UTF-8 strings using the native `TextDecoder` API. */\nexport const getUtf8Decoder = (): Decoder<string> => {\n    let textDecoder: TextDecoder;\n    return {\n        decode(bytes, offset = 0) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n        description: 'utf8',\n        fixedSize: null,\n        maxSize: null,\n    };\n};\n\n/** Encodes and decodes UTF-8 strings using the native `TextEncoder` and `TextDecoder` API. */\nexport const getUtf8Codec = (): Codec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    BaseCodecOptions,\n    Codec,\n    CodecData,\n    combineCodec,\n    Decoder,\n    Encoder,\n    fixDecoder,\n    fixEncoder,\n    mergeBytes,\n} from '@solana/codecs-core';\nimport { getU32Decoder, getU32Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { getUtf8Decoder, getUtf8Encoder } from './utf8';\n\n/** Defines the options for string codecs. */\nexport type StringCodecOptions<\n    TPrefix extends NumberCodec | NumberEncoder | NumberDecoder,\n    TEncoding extends Codec<string> | Encoder<string> | Decoder<string>\n> = BaseCodecOptions & {\n    /**\n     * The size of the string. It can be one of the following:\n     * - a {@link NumberCodec} that prefixes the string with its size.\n     * - a fixed number of bytes.\n     * - or `'variable'` to use the rest of the byte array.\n     * @defaultValue u32 prefix.\n     */\n    size?: TPrefix | number | 'variable';\n\n    /**\n     * The codec to use for encoding and decoding the content.\n     * @defaultValue UTF-8 encoding.\n     */\n    encoding?: TEncoding;\n};\n\n/** Encodes strings from a given encoding and size strategy. */\nexport const getStringEncoder = (options: StringCodecOptions<NumberEncoder, Encoder<string>> = {}): Encoder<string> => {\n    const size = options.size ?? getU32Encoder();\n    const encoding = options.encoding ?? getUtf8Encoder();\n    const description = options.description ?? `string(${encoding.description}; ${getSizeDescription(size)})`;\n\n    if (size === 'variable') {\n        return { ...encoding, description };\n    }\n\n    if (typeof size === 'number') {\n        return fixEncoder(encoding, size, description);\n    }\n\n    return {\n        description,\n        encode: (value: string) => {\n            const contentBytes = encoding.encode(value);\n            const lengthBytes = size.encode(contentBytes.length);\n            return mergeBytes([lengthBytes, contentBytes]);\n        },\n        fixedSize: null,\n        maxSize: null,\n    };\n};\n\n/** Decodes strings from a given encoding and size strategy. */\nexport const getStringDecoder = (options: StringCodecOptions<NumberDecoder, Decoder<string>> = {}): Decoder<string> => {\n    const size = options.size ?? getU32Decoder();\n    const encoding = options.encoding ?? getUtf8Decoder();\n    const description = options.description ?? `string(${encoding.description}; ${getSizeDescription(size)})`;\n\n    if (size === 'variable') {\n        return { ...encoding, description };\n    }\n\n    if (typeof size === 'number') {\n        return fixDecoder(encoding, size, description);\n    }\n\n    return {\n        decode: (bytes: Uint8Array, offset = 0) => {\n            assertByteArrayIsNotEmptyForCodec('string', bytes, offset);\n            const [lengthBigInt, lengthOffset] = size.decode(bytes, offset);\n            const length = Number(lengthBigInt);\n            offset = lengthOffset;\n            const contentBytes = bytes.slice(offset, offset + length);\n            assertByteArrayHasEnoughBytesForCodec('string', length, contentBytes);\n            const [value, contentOffset] = encoding.decode(contentBytes);\n            offset += contentOffset;\n            return [value, offset];\n        },\n        description,\n        fixedSize: null,\n        maxSize: null,\n    };\n};\n\n/** Encodes and decodes strings from a given encoding and size strategy. */\nexport const getStringCodec = (options: StringCodecOptions<NumberCodec, Codec<string>> = {}): Codec<string> =>\n    combineCodec(getStringEncoder(options), getStringDecoder(options));\n\nfunction getSizeDescription(size: CodecData | number | 'variable'): string {\n    return typeof size === 'object' ? size.description : `${size}`;\n}\n"]}